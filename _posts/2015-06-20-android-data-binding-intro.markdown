---
layout: post
title: "Getting Started with Data Binding in Android"
date: 2015-06-20 21:45:32 -0700
comments: true
---

In May, 2015 at Google announced [a data binding library for Android](https://developer.android.com/tools/data-binding/guide.html). The data binding library is currently in beta, so things might change and make what I am saying here irrelevant/obsolete. When in doubt, consult the official documentation.

It's long overdue &ndash; developers no longer have to come up with their own schemes for displaying or retrieving data from their views. With two-way data binding, it's possible to remove a lot of redundant boilerplate code from the activities and fragments that make up an application.

There were several steps/phases when I tried to implement data binding in a side project of mine. Here's what I did:

1. **Add data binding to Android Studio** &ndash; This is a one time thing.
2. **Create a POJO for the binding** &ndash; You don't necessarily want to bind to a domain object. Arguable it's a cleaner design to have another class with responsiblity of data binding (and maybe some validation too).
3. **Update the layout file** &ndash; We help the data binding library out by adding some meta-data/markup to our layout files.
4. **Update the activity to declare the data binding** &ndash; Connect the POJO and the layout file together.

# Adding Data Binding to Your Project

First off, I had to upgrade to Android Studio 1.3. This meant I had to switch the updates from the *Stable* channel to the *Beta* channel. You can do this by looking in **Android Studio > Preferences**, and then under **Appearance & Behaviour > System Settings > Updates**.

Next I had to edit the project's **build.gradle** file, my  `dependencies` section looks like this:

	dependencies {
	    classpath "com.android.tools.build:gradle:1.3.0-beta1"
	    classpath "com.android.databinding:dataBinder:1.0-rc0"
	}

After that, I updated the **build.gradle** for the app module. The first two line in the file are:

	apply plugin: 'com.android.application'
	apply plugin: 'com.android.databinding'

That's pretty much about it. Now that our project is aware of data binding, let's see about the code and UI changes I had to make.

# Using Data Binding

From here, you might be best off reading [Google's docs on data binding](https://developer.android.com/tools/data-binding/guide.html), just to get a feel for how things work. If you're familiar with data binding in XAML (say WPF or Xamarin.Forms), you might notice some simularities.

(*Allow me digress a bit and offer this piece of advice: think twice about binding directly to your model. This is a perfect opportunity to bring some Model-View-View Model goodness into your Android application. I'm not going to talk to much about MVVM though.*)

## Updating the Source Code

To keep my Activity as code free as possible, I abstracted much of the data binding logic into the following class (his isn't all the code, just the parts relevant for this example):

	public class FirearmViewModel extends BaseObservable {
	    private String mFirearmName;

	    // Constructors and other things omitted for clarity.

	    @Bindable
	    public String getName() {
	        return mFirearmName;
	    }

	    public void setName(String name) {
	        mFirearmName = name;
	        notifyPropertyChanged(BR.name);
	    }


	}

Here I'm just using a POJO that subclasses `BaseObservable`. Subclassing isn't mandatory &ndash; a naked POJO will work too. However, `BaseObservable` provides the infrastructure for setting up the data binding; the POJO can notify registered listeners as values change.

Some getters are adorned with the `@Bindable` annotation - this identifies how the listeners should retrieve values from the properties.

It's the responsibility of the bound class to notify clients when a property has changed. You can see this happening with the use of `notifyPropertyChanged`, where it is passed a value `BR.name`. This causes a signal to be raised to listeners; this is how they find out the name has changed.

The `BR` class is generated by the data binding library. It is to data binding what the `R` class is to layout files. Each POJO field or method adorned with `@Bindable` will have a constant declared in the `BR` class at compile time corresponding to the name. So, `getName()` becomes `BR.name`. Likewise, the data binding library knows to associate `setName` as the setter for this value.

With the code out of the way, it's time to update the layout.

## Update the XML Layout

There were a couple of changes that I needed to make to my existing layout for things to work:

1. Declare some variables in my layout.
2. Identify properties on the various widgets that will be bound to the variable declared above.
3. Establish the data binding in the Activity.

Android's data binding requires that `<layout>` be the root element of the layout. My old layout started with a `<LinearLayout>`. It's also necessary to add a `<data/>` section that will declare variables and the classes that will be bound to.

### Declare A Variable

We need to declare a variable that the data binding framework can... bind too. I had to add a `<data>` element with a child `<variable>` element that names the variable and identifies the type Android should use for the binding:

	<layout xmlns:android="http://schemas.android.com/apk/res/android"
	    xmlns:app="http://schemas.android.com/apk/res-auto">

	    <data>
	        <variable
	            name="firearm"
	            type="net.opgenorth.hayha.droid.views.settings.firearm.FirearmViewModel" />

	    </data>

	    <!-- my old layout is here, but omitted for clarity -->

	</layout>

Notice that the `xmlns:app="http://schemas.android.com/apk/res-auto"` will automatically drag local namespaces into your XML. This helps you out a bit because you don't have to explicitly declare all the namespaces in layout file.

### Declare the Bindings in the Layout

Next, I need to set up the binding. In this example, all I want to do is to bind `setName()`/`getName()` in my POJO to an `EditText`. This little XML snippet shows the binding in action:

    <EditText
        android:id="@+id/new_firearm_name_text_view"
        android:text="@{firearm.name}"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:contentDescription="firearm_name"
        android:hint="@string/firearm_name_hint"
        android:textSize="@dimen/default_font_size" />

Notice the syntax to declare the binding: `@{firearm.name}`. With this in place, the last thing to do is to setup the data binding in the activity.

# Establish the Data Binding

Finally, the easy stuff - setting up the data binding. This is a very minimal amount of code. We no longer have to first get a reference to a view, access properties on the view, and then manually transfer the value of that view to some domain object or variable in our application.  Below is a snippet from an Activity that shows how to set up the databinding:

	public class AddNewFirearmActivity extends AppCompatActivity{
	    private FirearmViewModel mViewModel;

	    @Override
	    protected void onCreate(Bundle savedInstanceState) {
	        super.onCreate(savedInstanceState);

	        mViewModel = createViewModel();
	        initializeViewModel();
	    }
	    private FirearmViewModel createViewModel() {
	    	// Code deliberately omitted.
	    }

	    private void initializeViewModel() {

	        ActivityAddNewFirearmBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_add_new_firearm);
	        binding.setFirearm(mViewModel);
	    }

	    // Rest of the code omitted.
	}




Notice that there is no call to `setContentView`, nor are there any instance variables holding references to vies. Likewise, my activity no burdened with any data validation code (that too is tucked away inside my view model class). The data binding library does some code generation for me, in particular it will create a data binding class based on the layout file `activity_add_new_firearm` called `ActivityAddNewFirearmBinding`. Notice that the name of this class is based off the name of the layout, converted to Pascal case with the work `Binding` appended to it.

Once the binding is instantiated, I tell it what object to bind to. Notice as well that the data binding library created a setter called `setFirearm` &ndash; this is because we declared the variable `firearm` in our layout file above.

# Sie Sind Fertig

With all this, data binding has been accomplished. It may seem like a lot of code, and perhaps it is for such a trivial example. Where the true power of this comes into play is when you want to write tests for your code. Two way data binding lays the framework for the Model-View-View Model pattern, which in turn helps you create a loosely coupled app that is easier to test.
